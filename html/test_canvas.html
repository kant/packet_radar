<html>
<body>
<style>
    body {
        background: #000;
    }
</style>
<script>

function rand(n) {
    // returns -0.5,0.5
    return (Math.random() - 0.5) * n;
}

 class DownAndDragAction {
        constructor(dom, cb) {
            this.cb = cb;
            this.down = false;
            this.dom = dom;

            this.to_release = {
                mousedown: dom.addEventListener('mousedown', this.mousedown.bind(this)),
                mousemove: dom.addEventListener('mousemove', this.mousemove.bind(this)),
                mouseup: dom.addEventListener('mouseup', this.mouseup.bind(this))
            };
        }

        mousedown(e) {
            this.down = true;
            console.log(e.x, e.y);
            this.cb(e.x, e.y);
        }

        mousemove(e) {
            if (!this.down) return;
            console.log(e.x, e.y);
            this.cb(e.x, e.y);
        }

        mouseup(e) {
            this.down = false;
            console.log(e.x, e.y);
            this.cb(e.x, e.y);
        }

        release() {
            for (var k in this.to_release) {
                this.dom.removeEventListener(k, this.to_release[k]);
            }

            this.to_release = null;
            this.dom = null;
            this.cb = null;
        }
    }


    class OnUpAction {
        constructor(dom, cb) {
            this.cb = cb;
            this.down = false;
            this.dom = dom;

            this.to_release = {
                mouseup: dom.addEventListener('mouseup', this.mouseup.bind(this))
            };
        }

        mouseup(e) {
            this.cb(e.x, e.y);
        }

        release() {
            for (var k in this.to_release) {
                this.dom.removeEventListener(k, this.to_release[k]);
            }

            this.to_release = null;
            this.dom = null;
            this.cb = null;
        }
    }


</script>
<script src="js/canvas.js"></script>

<script>

    // class World {
    //     constructor() {

    //     }
    // }


    // Init
    canvas = new qCanvas();

    document.body.appendChild(canvas.dom);

    var px, py;
    new DownAndDragAction(canvas.dom, (x, y) => {
        x = x - innerWidth / 2
        y = y - innerHeight / 2
        var node = new qNode(x, y);
        if (!px) {
            px = x;
            py = y;
        }
        node.px = x + rand(20);
        node.py = y + rand(20);
        // node.px = px;
        // node.py = py;
        px = x;
        py = y;
        node.life = 20;
        canvas.add(node);
    })

    new OnUpAction(canvas.dom, () => {
        px = null;
        py = null;
    })


    var simulate = 
    [
    function simulate1(delta) {
        const nodes = canvas.nodes;

        nodes.forEach(o => {
            var dx = o.x - o.px;
            var dy = o.y - o.py;

            o.x += dx;
            o.y += dy;
            o.life--;

            if (o.life < 0) {
                canvas.remove(o);
            }
        });
    },

    function simulate2(dt) {
        const nodes = canvas.nodes;

        nodes.forEach(o => {
            var dx = o.x - o.px;
            var dy = o.y - o.py;

            var friction = 0.5;
            o.x += dx * friction;
            o.y += dy * friction;
            o.life--;

            if (o.life < 0) {
                canvas.remove(o);
            }
        });
    },

    function simulate3(dt) {
        const nodes = canvas.nodes;

        nodes.forEach(o => {
            var dx = o.x - o.px;
            var dy = o.y - o.py;

            var friction = 0.5;
            o.x += dx * friction * dt;
            o.y += dy * friction * dt;
            o.life--;

            if (o.life < 0) {
                canvas.remove(o);
            }
        });
    },

    function simulate5(dt) {
        // bug fix, slido!
        const nodes = canvas.nodes;

        nodes.forEach(o => {
            var dx = o.x - o.px;
            var dy = o.y - o.py;

            var friction = 0.9;
            o.px = o.x;
            o.py = o.y;
            o.x += dx * friction;
            o.y += dy * friction;
            

            o.life--;

            if (o.life < 0) {
                canvas.remove(o);
            }
        });
    },

   
    function simulate6(dt) {
         // mutual attraction
        const nodes = canvas.nodes;

        nodes.forEach(o => {
            var dx = o.x - o.px;
            var dy = o.y - o.py;

            var friction = 0.95;
            o.px = o.x;
            o.py = o.y;
            o.x += dx * friction;
            o.y += dy * friction;
            
            o.life--;

            if (o.life < 0) {
                canvas.remove(o);
            }
        });
    },

    ].pop()

    var last_step = Date.now();
    setInterval(()  => {
        var now = Date.now();
        var diff = (now - last_step) / 1000;
        last_step = now;

        // simulate
        simulate(diff);

        // render
        canvas.render();
    }, 30);
</script>
</body>
</html>